---
title: "clustering-in-R"
author: "Erin Shellman"
date: "June 1, 2015"
output:
  pdf_document:
    toc: yes
    toc_depth: 2
  html_document:
    theme: readable
    toc: yes
    toc_depth: 3
---

```{r setup, include = FALSE}
# my set-up
knitr::opts_chunk$set(cache = TRUE)
require(dplyr)
require(ggplot2)
require(scales)
require(gridExtra)
setwd('~/projects/BI-TECH-CP303/projects/project 3')
catalog = read.delim('./data/product_catalog.tsv',
                     header = TRUE,
                     sep = '\t',
                     quote = '')
```

# Read in data

```{r}
install.packages('cluster', dependencies = TRUE)
install.packages('gridExtra', dependencies = TRUE)
library(cluster)
library(dplyr)
library(ggplot2)
library(scales)
library(gridExtra)

# read in the product catalog
catalog = read.delim('product_catalog.tsv',
                     header = TRUE,
                     sep = '\t'
                     quote = '')

menace = catalog[catalog$id == 5335, ]
data_mining = catalog[catalog$id == 22025, ]
```

# Preprocessing

Most clustering techniques work best when the data are centered and scaled.
Recall that an observation is centered when you subtract from it its mean. An 
observation is scaled when you divide an observation by its standard deviation.
When we center and scale a variable, the resulting variable follows a 
z-distribution with mean = 0 and sd = 1.

```{r}
# remove rows containing missing data
catalog = na.omit(catalog)

# rename row names to be product ids
row.names(catalog) = catalog$id

# most products are books, music, video or DVDs, so lets focus on those
table(catalog$group)

# subset
sub = 
  catalog %>%
    filter(group == 'Book' | group == 'DVD' | 
           group == 'Music' | group == 'Video') %>% 
    select(id, avg_rating, downloaded, reviews_count, salesrank, group)
rownames(sub) = sub$id
sub$id = NULL
```

Clustering methods need scaled numeric inputs to compute distance metrics. 
Before we can scale the data, we need to convert the product group from a factor
into a numeric value.

```{r}
# convert the group into dummy variables
group_dummies = model.matrix(~ factor(sub$group) - 1)
colnames(group_dummies) = c('book', 'dvd', 'music', 'video')

# append the dummy variables back on and drop the 'group' variable
sub = cbind(sub, group_dummies)
sub$group = NULL

# scale the data 
scaled = as.data.frame(scale(sub))
scaled = as.data.frame(t(scale(t(sub))))

# what is the effect of scaling?
plot1 = qplot(avg_rating, data = sub, geom = 'histogram')
plot2 = qplot(downloaded, data = sub, geom = 'histogram')
plot3 = qplot(reviews_count, data = sub, geom = 'histogram')
plot4 = qplot(salesrank, data = sub, geom = 'histogram')
grid.arrange(plot1, plot2, plot3, plot4, ncol = 4)

plot1 = qplot(avg_rating, data = scaled, geom = 'histogram')
plot2 = qplot(downloaded, data = scaled, geom = 'histogram')
plot3 = qplot(reviews_count, data = scaled, geom = 'histogram')
plot4 = qplot(salesrank, data = scaled, geom = 'histogram')
grid.arrange(plot1, plot2, plot3, plot4, ncol = 4)

```

# Distance

```{r}
# Don't be a menace
menace = sub[rownames(sub) == 5335, ]
x = 
  sub %>%
    filter(video == 1, avg_rating == 4.5) %>%
    sample_n(20)
x = rbind(menace, x)

euclidean = dist(x, method = 'euclidean')

hr = hclust(euclidean, members = rownames(x))
```

# K-means clustering

```{r}
# set the seed
set.seed(100)
  
# run k-means clustering
kmeans = kmeans(sub, 4)
kmeans$centers
plot(sub[ , 3], sub[ , 4], col = kmeans$cluster)
points(kmeans$centers[, c(1, 2)], col = 1:3, pch = 19, cex = 2)

ggplot(sub, aes(x = reviews_count, y = salesrank, color = factor(kmeans$cluster))) +
  geom_point() +
  #geom_point(aes(kmeans$centers[]) +  
  theme_minimal() 
```


